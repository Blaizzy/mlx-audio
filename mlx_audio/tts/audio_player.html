<title>3D Orb Audio Visualization</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            max-width: 350px;
            max-height: 80vh;
            overflow-y: auto;
        }
        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 8px 16px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #stopBtn {
            background-color: #f44336;
        }
        #status {
            margin-top: 10px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="text"], select, textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
            background-color: rgba(255, 255, 255, 0.9);
        }
        textarea {
            height: 80px;
            resize: vertical;
        }
        .tab-container {
            margin-top: 15px;
        }
        .tab {
            overflow: hidden;
            border-bottom: 1px solid #ccc;
            margin-bottom: 10px;
        }
        .tab button {
            background-color: inherit;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 8px 16px;
            transition: 0.3s;
            color: #ddd;
        }
        .tab button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .tab button.active {
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
        }
        .tabcontent {
            display: none;
            padding: 10px 0;
        }
        .error {
            color: #ff6b6b;
            font-weight: bold;
            margin-top: 10px;
        }
        /* Improved slider styling */
        .slider-container {
            margin-top: 10px;
            position: relative;
        }
        .slider-labels {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 12px;
            color: #ddd;
        }
        input[type="range"] {
            width: 100%;
            margin: 0;
            background: transparent;
            -webkit-appearance: none;
        }
        input[type="range"]:focus {
            outline: none;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }
        input[type="range"]::-webkit-slider-thumb {
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -5px;
        }
        input[type="range"]::-moz-range-track {
            width: 100%;
            height: 6px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }
        input[type="range"]::-moz-range-thumb {
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }
        .speed-value-display {
            position: relative;
            text-align: center;
            font-weight: bold;
            color: white;
            margin-top: 5px;
            font-size: 14px;
        }
    </style>
</head>
<body>

    <div id="controls">
        <h1>MLX-Audio Player</h1>
        
        <div class="tab">
            <button class="tablinks active" onclick="openTab(event, 'textToSpeech')">Text to Speech</button>
            <button class="tablinks" onclick="openTab(event, 'fileUpload')">File Upload</button>
        </div>
        
        <div id="textToSpeech" class="tabcontent" style="display: block;">
            <div class="form-group">
                <label for="text">Text to convert:</label>
                <textarea id="text" placeholder="Enter text here..."></textarea>
            </div>
            
            <div class="form-group">
                <label for="voice">Voice:</label>
                <select id="voice">
                    <option value="af_bella">AF Bella</option>
                    <option value="af_heart">AF Heart</option>
                    <option value="af_nicole">AF Nicole</option>
                    <option value="af_nova">AF Nova</option>
                    <option value="af_sarah">AF Sarah</option>
                    <option value="af_sky">AF Sky</option>
                    <option value="am_adam">AM Adam</option>
                    <option value="am_michael">AM Michael</option>
                    <option value="bf_emma">BF Emma</option>
                    <option value="bf_isabella">BF Isabella</option>
                    <option value="bm_george">BM George</option>
                    <option value="bm_lewis">BM Lewis</option>
                  </select>
            </div>
            
            <div class="form-group">
                <label for="model">Model:</label>
                <select id="model">
                    <option value="mlx-community/Kokoro-82M-4bit">Kokoro 82M 4bit</option>
                    <option value="mlx-community/Kokoro-82M-6bit">Kokoro 82M 6bit</option>
                    <option value="mlx-community/Kokoro-82M-8bit">Kokoro 82M 8bit</option>
                    <option value="mlx-community/Kokoro-82M-bf16">Kokoro 82M bf16</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="speed">Speech Speed:</label>
                <div class="slider-container">
                    <div class="slider-labels">
                        <span>Slower</span>
                        <span>Normal</span>
                        <span>Faster</span>
                    </div>
                    <input type="range" id="speed" min="0.5" max="2.0" step="0.1" value="1.0">
                    <div class="speed-value-display"><span id="speed-value">1.0</span>x</div>
                </div>
            </div>
            
            <button id="generateBtn">Generate Speech</button>
            <button id="openFolderBtn" style="background-color: #2196F3;">Open Output Folder</button>
            <div id="ttsError" class="error" style="display: none;"></div>
            <div id="ttsStatus" style="margin-top: 10px; max-width: 350px;"></div>
        </div>
        
        <div id="fileUpload" class="tabcontent">
            <input type="file" id="audioUpload" accept="audio/*">
            <div style="margin-top: 10px;">
                <button id="playBtn" disabled>Play</button>
                <button id="stopBtn" disabled>Stop</button>
            </div>
            <div id="status">Upload an audio file to begin visualization</div>
        </div>
    </div>

    <!-- Load Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // DOM elements
        const audioUpload = document.getElementById('audioUpload');
        const playBtn = document.getElementById('playBtn');
        const stopBtn = document.getElementById('stopBtn');
        const statusElement = document.getElementById('status');

        // TTS elements
        const textInput = document.getElementById('text');
        const voiceSelect = document.getElementById('voice');
        const modelSelect = document.getElementById('model');
        const speedInput = document.getElementById('speed');
        const speedValue = document.getElementById('speed-value');
        const generateBtn = document.getElementById('generateBtn');
        const openFolderBtn = document.getElementById('openFolderBtn');
        const ttsErrorElement = document.getElementById('ttsError');
        const ttsStatusElement = document.getElementById('ttsStatus');

        // Audio variables
        let audioContext;
        let analyser;
        let dataArray;
        let audioElement;
        let audioSource;

        // Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000);
        document.body.appendChild(renderer.domElement);

        // Add orbit controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Position camera
        camera.position.set(0, 0, 100);
        camera.lookAt(0, 0, 0);

        // Add lights
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0xffffff, 1, 100);
        pointLight.position.set(0, 0, 0);
        scene.add(pointLight);

        // Create particle system instead of sphere mesh
        const particleCount = 2000; // More particles for a dense, wild look
        const particlesGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);

        // Distribute particles in a spherical cloud with some randomness
        for (let i = 0; i < particleCount; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const r = 30 * (0.7 + Math.random() * 0.6); // Vary radius for a chaotic, cloud-like effect

            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);

            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;

            // White particles for glowing effect
            colors[i * 3] = 1.0;     // R
            colors[i * 3 + 1] = 1.0; // G
            colors[i * 3 + 2] = 1.0; // B
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Square particle material (using a simple white square texture)
        const particleMaterial = new THREE.PointsMaterial({
            size: 0.6, // Slightly larger for visibility
            vertexColors: true,
            map: new THREE.TextureLoader().load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAFElEQVR42mNgwAJSMA/9f4HgY2BgguBJmgQHoAbpQJQcP8AARCcAUsn3dr4AAAAASUVORK5CYII='), // 1x1 white square
            transparent: true,
            opacity: 0.9,
            depthWrite: false,
            blending: THREE.AdditiveBlending // Glowing, ethereal effect
        });

        const particles = new THREE.Points(particlesGeometry, particleMaterial);
        scene.add(particles);

        // Store original positions for reset and animation
        const originalPositions = positions.slice();        
        
        // Create connecting lines for the surge effect
        const linesGeometry = new THREE.BufferGeometry();
        const linePositions = new Float32Array(particleCount * 6); // Each line has 2 points
        let lineIndex = 0;

        // Connect nearby particles (wild, organic web)
        for (let i = 0; i < particleCount; i++) {
            for (let j = i + 1; j < particleCount; j++) {
                const iPos = new THREE.Vector3(
                    positions[i * 3],
                    positions[i * 3 + 1],
                    positions[i * 3 + 2]
                );
                const jPos = new THREE.Vector3(
                    positions[j * 3],
                    positions[j * 3 + 1],
                    positions[j * 3 + 2]
                );
                const distance = iPos.distanceTo(jPos);

                if (distance < 12 && Math.random() > 0.9) { // Sparse connections for a wild look
                    linePositions[lineIndex++] = iPos.x;
                    linePositions[lineIndex++] = iPos.y;
                    linePositions[lineIndex++] = iPos.z;
                    linePositions[lineIndex++] = jPos.x;
                    linePositions[lineIndex++] = jPos.y;
                    linePositions[lineIndex++] = jPos.z;
                }
            }
        }

        linesGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions.slice(0, lineIndex), 3));
        const lineMaterial = new THREE.LineBasicMaterial({
            color: 0xffa500, // Vibrant orange
            transparent: true,
            opacity: 0.4,
            depthWrite: false,
            blending: THREE.AdditiveBlending // Glowing lines
        });

        const lines = new THREE.LineSegments(linesGeometry, lineMaterial);
        scene.add(lines);        

        // Define rotation speed variables
        let rotationSpeedY = 0.002;
        let rotationSpeedX = 0.001;
        let isGenerating = false;

        // Tab functionality
        function openTab(evt, tabName) {
            // Hide all tabcontent
            const tabcontent = document.getElementsByClassName("tabcontent");
            for (let i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }
            
            // Remove active class from all tablinks
            const tablinks = document.getElementsByClassName("tablinks");
            for (let i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }
            
            // Show the current tab and add active class to the button
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";
        }
        
        // Speed slider update
        speedInput.addEventListener('input', function() {
            speedValue.textContent = this.value;
        });
        
        // Generate speech button handler
        generateBtn.addEventListener('click', function() {
            const text = textInput.value;
            const voice = voiceSelect.value;
            const model = modelSelect.value;
            const speed = speedInput.value;
            
            if (!text.trim()) {
                showTtsError('Please enter some text');
                return;
            }
            
            // Hide previous error
            ttsErrorElement.style.display = 'none';
            ttsStatusElement.textContent = 'Generating speech...';
            
            // Increase rotation speed to indicate processing
            isGenerating = true;
            rotationSpeedY = 0.01;
            rotationSpeedX = 0.005;
            
            // Create form data
            const formData = new FormData();
            formData.append('text', text);
            formData.append('voice', voice);
            formData.append('model', model);
            formData.append('speed', speed);
            
            // Send request to server
            fetch('/tts', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(data => {
                        throw new Error(data.error || 'Failed to generate speech');
                    });
                }
                return response.json();
            })
            .then(data => {
                ttsStatusElement.textContent = 'Speech generated successfully!';
                
                // Reset rotation speed
                isGenerating = false;
                rotationSpeedY = 0.002;
                rotationSpeedX = 0.001;
                
                // Clean up previous audio resources
                if (audioElement) {
                    audioElement.pause();
                    audioElement.removeAttribute('src');
                    audioElement.load();
                }
                
                if (audioSource) {
                    audioSource.disconnect();
                    audioSource = null;
                }
                
                // Create new audio element to avoid source node issues
                audioElement = new Audio();
                
                // Set audio source with absolute path
                audioElement.src = `/audio/${data.filename}`;
                audioElement.loop = false;
                
                // Enable play button
                playBtn.disabled = false;
                stopBtn.disabled = true;
                
                // Add ended event listener
                audioElement.addEventListener('ended', function() {
                    statusElement.textContent = "Audio finished playing.";
                    playBtn.disabled = false;
                    stopBtn.disabled = true;
                    resetSphere();
                });
                
                // Auto-play the generated audio
                playAudio();
            })
            .catch(error => {
                showTtsError(error.message);
                
                // Reset rotation speed on error too
                isGenerating = false;
                rotationSpeedY = 0.002;
                rotationSpeedX = 0.001;
            });
        });
        
        // Open output folder button handler
        openFolderBtn.addEventListener('click', function() {
            fetch('/open_output_folder', {
                method: 'POST'
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(data => {
                        throw new Error(data.error || 'Failed to open output folder');
                    });
                }
                return response.json();
            })
            .then(data => {
                ttsStatusElement.textContent = `Opened output folder: ${data.path}`;
            })
            .catch(error => {
                showTtsError(error.message);
            });
        });
        
        function showTtsError(message) {
            ttsErrorElement.textContent = message;
            ttsErrorElement.style.display = 'block';
        }
        
        // Function to play audio (reused for both upload and TTS)
        function playAudio() {
            if (!audioElement || !audioElement.src) {
                statusElement.textContent = "No audio available to play.";
                return;
            }
            
            statusElement.textContent = "Playing audio...";
            
            // Initialize audio context if needed
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            // Create analyser if needed
            if (!analyser) {
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
            }
            
            // Connect audio element to analyser if not already connected
            if (!audioSource) {
                try {
                    audioSource = audioContext.createMediaElementSource(audioElement);
                    audioSource.connect(analyser);
                    analyser.connect(audioContext.destination);
                } catch (error) {
                    console.error("Error connecting audio source:", error);
                    statusElement.textContent = "Error setting up audio visualization. Try refreshing the page.";
                    
                    // Still try to play the audio even if visualization fails
                    audioElement.play().catch(playError => {
                        statusElement.textContent = "Error playing audio: " + playError.message;
                    });
                    return;
                }
            }
            
            // Play audio
            audioElement.play().then(() => {
                playBtn.disabled = true;
                stopBtn.disabled = false;
            }).catch(error => {
                statusElement.textContent = "Error playing audio: " + error.message;
            });
        }

        // Handle audio upload
        audioUpload.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            statusElement.textContent = "Audio file loaded. Press Play to start.";

            // Clean up previous audio resources
            if (audioElement) {
                audioElement.pause();
                audioElement.removeAttribute('src');
                audioElement.load();
            }
            
            if (audioSource) {
                audioSource.disconnect();
                audioSource = null;
            }
            
            // Create new audio element
            audioElement = new Audio();
            audioElement.src = URL.createObjectURL(file);
            audioElement.loop = false;

            // Enable play button
            playBtn.disabled = false;
            stopBtn.disabled = true;

            // Add ended event listener
            audioElement.addEventListener('ended', function() {
                statusElement.textContent = "Audio finished playing.";
                playBtn.disabled = false;
                stopBtn.disabled = true;
                resetSphere();
            });
        });

        // Play button handler
        playBtn.addEventListener('click', function() {
            playAudio();
        });

        // Stop button handler
        stopBtn.addEventListener('click', function() {
            if (audioElement) {
                audioElement.pause();
                audioElement.currentTime = 0;
                statusElement.textContent = "Audio stopped. Press Play to restart.";
                playBtn.disabled = false;
                stopBtn.disabled = true;

                // Reset sphere to original state
                resetSphere();
            }
        });

        // Reset sphere to original state
// Reset particle positions
        function resetSphere() {
            const positionAttribute = particlesGeometry.attributes.position;
            for (let i = 0; i < particleCount; i++) {
                positionAttribute.setXYZ(
                    i,
                    originalPositions[i * 3],
                    originalPositions[i * 3 + 1],
                    originalPositions[i * 3 + 2]
                );
            }
            positionAttribute.needsUpdate = true;

            const linePositionAttribute = linesGeometry.attributes.position;
            for (let i = 0; i < lineIndex / 3; i++) {
                const particle1Index = Math.floor(i * 2);
                const particle2Index = particle1Index + 1;

                linePositionAttribute.setXYZ(
                    i * 2,
                    positionAttribute.getX(particle1Index),
                    positionAttribute.getY(particle1Index),
                    positionAttribute.getZ(particle1Index)
                );
                linePositionAttribute.setXYZ(
                    i * 2 + 1,
                    positionAttribute.getX(particle2Index),
                    positionAttribute.getY(particle2Index),
                    positionAttribute.getZ(particle2Index)
                );
            }
            linePositionAttribute.needsUpdate = true;
        }

        // Animation loop
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            controls.update();

            const time = performance.now() * 0.001;

            // Rotate particles and lines together
            particles.rotation.y += rotationSpeedY;
            particles.rotation.x += rotationSpeedX;
            lines.rotation.copy(particles.rotation);

            if (analyser && dataArray && !audioElement.paused) {
                analyser.getByteFrequencyData(dataArray);

                const bassAvg = getAverageFrequency(dataArray, 0, 5);
                const midAvg = getAverageFrequency(dataArray, 6, 20);
                const trebleAvg = getAverageFrequency(dataArray, 21, 40);

                const pulseFactor = Math.sin(time * 2) * 0.05 + 1; // Faster pulsation for energy

                // Update particle positions for wild surge effect
                const positionAttribute = particlesGeometry.attributes.position;
                for (let i = 0; i < particleCount; i++) {
                    const originalX = originalPositions[i * 3];
                    const originalY = originalPositions[i * 3 + 1];
                    const originalZ = originalPositions[i * 3 + 2];

                    const vertexLength = Math.sqrt(originalX * originalX + originalY * originalY + originalZ * originalZ);
                    let surgeFactor;

                    // Creative surge: outer particles react to treble, inner to bass
                    if (vertexLength > 25) {
                        surgeFactor = trebleAvg / 255 * 2.5; // Outer surge
                    } else if (vertexLength > 15) {
                        surgeFactor = midAvg / 255 * 2; // Middle surge
                    } else {
                        surgeFactor = bassAvg / 255 * 3; // Inner surge (big kick!)
                    }

                    const scaleFactor = pulseFactor * (1 + surgeFactor);

                    positionAttribute.setXYZ(
                        i,
                        originalX * scaleFactor,
                        originalY * scaleFactor,
                        originalZ * scaleFactor
                    );
                }
                positionAttribute.needsUpdate = true;

                // Update line positions to follow particles
                const linePositionAttribute = linesGeometry.attributes.position;
                for (let i = 0; i < lineIndex / 3; i++) {
                    const particle1Index = Math.floor(i * 2);
                    const particle2Index = particle1Index + 1;

                    linePositionAttribute.setXYZ(
                        i * 2,
                        positionAttribute.getX(particle1Index),
                        positionAttribute.getY(particle1Index),
                        positionAttribute.getZ(particle1Index)
                    );
                    linePositionAttribute.setXYZ(
                        i * 2 + 1,
                        positionAttribute.getX(particle2Index),
                        positionAttribute.getY(particle2Index),
                        positionAttribute.getZ(particle2Index)
                    );
                }
                linePositionAttribute.needsUpdate = true;

                // Dynamic colors for a wild vibe
                const hue = (bassAvg / 255) * 0.2; // Subtle hue shift
                particleMaterial.color.setHSL(hue, 0.8, 0.6 + (trebleAvg / 255) * 0.3);
                lineMaterial.color.setHSL(0.1, 0.9, 0.5 + (midAvg / 255) * 0.2); // Orange with brightness variation

                // Point light reacts wildly
                pointLight.intensity = 1 + (bassAvg / 255) * 2;
                pointLight.color.setHSL(hue, 0.8, 0.5);
            } else {
                // Subtle pulsation when idle
                const pulseFactor = Math.sin(time * 2) * 0.05 + 1;

                const positionAttribute = particlesGeometry.attributes.position;
                for (let i = 0; i < particleCount; i++) {
                    const originalX = originalPositions[i * 3];
                    const originalY = originalPositions[i * 3 + 1];
                    const originalZ = originalPositions[i * 3 + 2];

                    positionAttribute.setXYZ(
                        i,
                        originalX * pulseFactor,
                        originalY * pulseFactor,
                        originalZ * pulseFactor
                    );
                }
                positionAttribute.needsUpdate = true;

                // Update line positions
                const linePositionAttribute = linesGeometry.attributes.position;
                for (let i = 0; i < lineIndex / 3; i++) {
                    const particle1Index = Math.floor(i * 2);
                    const particle2Index = particle1Index + 1;

                    linePositionAttribute.setXYZ(
                        i * 2,
                        positionAttribute.getX(particle1Index),
                        positionAttribute.getY(particle1Index),
                        positionAttribute.getZ(particle1Index)
                    );
                    linePositionAttribute.setXYZ(
                        i * 2 + 1,
                        positionAttribute.getX(particle2Index),
                        positionAttribute.getY(particle2Index),
                        positionAttribute.getZ(particle2Index)
                    );
                }
                linePositionAttribute.needsUpdate = true;

                // Idle colors
                particleMaterial.color.setHSL(0.6, 0.8, 0.5 + Math.sin(time) * 0.1);
                lineMaterial.color.setHSL(0.1, 0.8, 0.4);
                pointLight.intensity = 0.8 + Math.sin(time * 1.5) * 0.3;
            }

            renderer.render(scene, camera);
        }

        // Helper function to get average frequency in a range
        function getAverageFrequency(dataArray, startIndex, endIndex) {
            let sum = 0;
            for (let i = startIndex; i <= endIndex; i++) {
                sum += dataArray[i];
            }
            return sum / (endIndex - startIndex + 1);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start animation loop
        animate();
    </script>
</body>
</html>